## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *
from eudplib.epscript.helper import _RELIMP, _IGVA, _CGFW, _ARR, _VARR, _SRET, _SV, _ATTW, _ARRW, _ATTC, _ARRC, _L2V, _LVAR, _LSH
# (Line 1) object Test {
# (Line 2) var x, y, z;
class Test(EUDStruct):
    # (Line 3) function setX(x) { this.x = x; }
    @EUDMethod
    def setX(this, x):
        _ATTW(this, 'x') << (x)
        # (Line 4) function add(other: selftype) {

    @EUDTypedMethod([selftype])
    def add(this, other):
        # (Line 5) this.x += other.x;
        _ATTW(this, 'x').__iadd__(other.x)
        # (Line 6) this.y += other.y;
        _ATTW(this, 'y').__iadd__(other.y)
        # (Line 7) this.z += other.z;
        _ATTW(this, 'z').__iadd__(other.z)
        # (Line 8) }
        # (Line 9) };

    # (Line 10) function test_object() {
    _fields_ = [
        'x',
        'y',
        'z',
    ]

@EUDFunc
def f_test_object():
    # (Line 11) const a = Test();
    a = Test()
    # (Line 12) a.x, a.y = 5, 7;
    _SV([_ATTW(a, 'x'), _ATTW(a, 'y')], [5, 7])
    # (Line 14) const b = Test.cast(a);
    b = Test.cast(a)
    # (Line 15) const c = Test.cast(b);
    c = Test.cast(b)
    # (Line 17) b.z = 8;
    _ATTW(b, 'z') << (8)
    # (Line 18) c.x = 3;
    _ATTW(c, 'x') << (3)
    # (Line 21) var ret = a ? 1 : 0;
    ret = _LVAR([EUDTernary(a)(1)(0)])
    # (Line 22) if (a.x == b.x && b.x == c.x) ret += 2;
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'x') == b.x)(_ATTC(b, 'x') == c.x)()):
        ret.__iadd__(2)
        # (Line 23) if (a.y == b.y && b.y == c.y) ret += 4;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'y') == b.y)(_ATTC(b, 'y') == c.y)()):
        ret.__iadd__(4)
        # (Line 24) if (a.z == b.z && b.z == c.z) ret += 8;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'z') == b.z)(_ATTC(b, 'z') == c.z)()):
        ret.__iadd__(8)
        # (Line 25) if (a.x == 3 && b.y == 7 && c.z == 8) ret += 16;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(a, 'x') == 3)(_ATTC(b, 'y') == 7)(_ATTC(c, 'z') == 8)()):
        ret.__iadd__(16)
        # (Line 27) const d = a.copy();
    EUDEndIf()
    d = a.copy()
    # (Line 28) a.add(d);
    a.add(d)
    # (Line 29) if (c.x == 6 && a.y == 14 && b.z == 16) ret += 32;
    if EUDIf()(EUDSCAnd()(_ATTC(c, 'x') == 6)(_ATTC(a, 'y') == 14)(_ATTC(b, 'z') == 16)()):
        ret.__iadd__(32)
        # (Line 30) if (d.x == 3 && d.y == 7 && d.z == 8) ret += 64;
    EUDEndIf()
    if EUDIf()(EUDSCAnd()(_ATTC(d, 'x') == 3)(_ATTC(d, 'y') == 7)(_ATTC(d, 'z') == 8)()):
        ret.__iadd__(64)
        # (Line 32) var e = a;
    EUDEndIf()
    e = _LVAR([a])
    # (Line 33) Test.cast(e).setX(1);
    Test.cast(e).setX(1)
    # (Line 34) if (a.x == 1) ret += 128;
    if EUDIf()(_ATTC(a, 'x') == 1):
        ret.__iadd__(128)
        # (Line 36) return ret;  // 255
    EUDEndIf()
    EUDReturn(ret)
    # (Line 37) }
    # (Line 39) object Coord { var x, y; };

class Coord(EUDStruct):
    # (Line 40) object Triangle {
    _fields_ = [
        'x',
        'y',
    ]

# (Line 41) var p: Coord * 5;
class Triangle(EUDStruct):
    # (Line 42) var q;
    # (Line 43) };
    # (Line 44) function test_nested_object() {
    _fields_ = [
        ('p', Coord * 5),
        'q',
    ]

@EUDFunc
def f_test_nested_object():
    # (Line 45) const a = Triangle();
    a = Triangle()
    # (Line 46) a.p = (Coord * 5)();
    _ATTW(a, 'p') << ((Coord * 5)())
    # (Line 47) foreach(i : py_range(5)) {
    for i in range(5):
        # (Line 48) a.p[i] = Coord();
        _ARRW(a.p, i) << (Coord())
        # (Line 49) }
        # (Line 51) a.p[0].x = 1;

    _ATTW(a.p[0], 'x') << (1)
    # (Line 52) a.p[1].y = 2;
    _ATTW(a.p[1], 'y') << (2)
    # (Line 53) a.p[1].y += 2;
    _ATTW(a.p[1], 'y').__iadd__(2)
    # (Line 54) a.q = 3;
    _ATTW(a, 'q') << (3)
    # (Line 56) var ret = list(a.p[0].x == 1, a.p[0].y == 0, a.p[1].y == 4, a.q == 3) ? 1 : 0;
    ret = _LVAR([EUDTernary(FlattenList([_ATTC(a.p[0], 'x') == 1, _ATTC(a.p[0], 'y') == 0, _ATTC(a.p[1], 'y') == 4, _ATTC(a, 'q') == 3]))(1)(0)])
    # (Line 58) const b = a.copy();
    b = a.copy()
    # (Line 59) b.p[0].x = 5;
    _ATTW(b.p[0], 'x') << (5)
    # (Line 60) b.q = 2;
    _ATTW(b, 'q') << (2)
    # (Line 61) if (a.p[0].x == 5) ret += 2;
    if EUDIf()(_ATTC(a.p[0], 'x') == 5):
        ret.__iadd__(2)
        # (Line 62) if (b.p[0].x == 5) ret += 4;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[0], 'x') == 5):
        ret.__iadd__(4)
        # (Line 63) if (b.p[0].y == 0) ret += 8;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[0], 'y') == 0):
        ret.__iadd__(8)
        # (Line 64) if (b.p[1].y == 4) ret += 16;
    EUDEndIf()
    if EUDIf()(_ATTC(b.p[1], 'y') == 4):
        ret.__iadd__(16)
        # (Line 65) if (a.q == 3) ret += 32;
    EUDEndIf()
    if EUDIf()(_ATTC(a, 'q') == 3):
        ret.__iadd__(32)
        # (Line 66) if (b.q == 2) ret += 64;
    EUDEndIf()
    if EUDIf()(_ATTC(b, 'q') == 2):
        ret.__iadd__(64)
        # (Line 68) return ret;
    EUDEndIf()
    EUDReturn(ret)
    # (Line 69) }
    # (Line 71) object List {

# (Line 72) var prev: selftype, next: selftype;
class List(EUDStruct):
    # (Line 73) };
    # (Line 74) function test_selftype_member() {
    _fields_ = [
        ('prev', selftype),
        ('next', selftype),
    ]

@EUDFunc
def f_test_selftype_member():
    # (Line 75) const a, b = List(), List();
    a, b = List2Assignable([List(), List()])
    # (Line 76) a.prev = b;
    _ATTW(a, 'prev') << (b)
    # (Line 77) a.next = b;
    _ATTW(a, 'next') << (b)
    # (Line 78) b.prev = a;
    _ATTW(b, 'prev') << (a)
    # (Line 79) b.next = a;
    _ATTW(b, 'next') << (a)
    # (Line 80) }
